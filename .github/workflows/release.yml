name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version tag (e.g., v1.0.0). Leave empty to use package.json version."
        required: false
        type: string
      dry_run:
        description: "Dry run â€” build and sign but skip GitHub Release creation"
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  release:
    name: Build, Sign & Release
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="v$(node -p "require('./package.json').version")"
          fi
          echo "tag=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "version=${VERSION#v}" >> "$GITHUB_OUTPUT"
          echo "Using version: ${VERSION}"

      - name: Install dependencies
        run: npm ci

      - name: Import code signing certificate
        env:
          CERTIFICATE_P12_BASE64: ${{ secrets.CERTIFICATE_P12_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        run: |
          # Decode the certificate
          CERTIFICATE_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$CERTIFICATE_P12_BASE64" | base64 --decode > "$CERTIFICATE_PATH"

          # Create a temporary keychain
          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 24)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import the certificate into the keychain
          security import "$CERTIFICATE_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Allow codesign to access the keychain without UI prompt
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            "$KEYCHAIN_PATH"

          # Add the keychain to the search list (prepend so it's found first)
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

      - name: Prepare App Store Connect API key
        env:
          APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_BASE64 }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
        run: |
          # notarytool expects the key at ~/private_keys/AuthKey_<ID>.p8
          mkdir -p ~/private_keys
          echo "$APPLE_API_KEY_BASE64" | base64 --decode > ~/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8

      - name: Build app
        run: npm run build

      - name: Package and sign (DMG + zip)
        env:
          # electron-builder uses these for signing
          CSC_KEYCHAIN: ${{ env.KEYCHAIN_PATH }}
          # electron-builder uses these for notarization (built-in CI notarization)
          APPLE_API_KEY: ~/private_keys/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER_ID }}
        run: npx electron-builder --mac dmg zip --publish never

      - name: Clean up keychain
        if: always()
        run: |
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH"
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: vox-${{ steps.version.outputs.version }}-mac
          path: |
            out/*.dmg
            out/*.zip
          if-no-files-found: error

      - name: Prepare release assets
        if: ${{ !inputs.dry_run }}
        run: |
          # Find the built files
          DMG=$(find out -name "*.dmg" -type f | head -1)
          ZIP=$(find out -name "*.zip" -type f | head -1)

          # Create copies with stable names (no version) for the latest release
          cp "$DMG" out/Vox-arm64.dmg
          cp "$ZIP" out/Vox-arm64-mac.zip

          echo "DMG=$DMG" >> "$GITHUB_ENV"
          echo "ZIP=$ZIP" >> "$GITHUB_ENV"

      - name: Create versioned GitHub Release
        if: ${{ !inputs.dry_run }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"

          # Create the tag if it doesn't exist
          git tag "$TAG" 2>/dev/null || true
          git push origin "$TAG" 2>/dev/null || true

          gh release create "$TAG" \
            --title "Vox $TAG" \
            --generate-notes \
            "$DMG" "$ZIP"

          echo "Versioned release created: $TAG"

      - name: Update latest release
        if: ${{ !inputs.dry_run }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Delete existing latest release and tag if they exist
          gh release delete latest --yes 2>/dev/null || true
          git push origin :refs/tags/latest 2>/dev/null || true

          # Create new latest tag pointing to current commit
          git tag -f latest
          git push origin latest

          # Create the latest release with stable-name assets
          gh release create latest \
            --title "Vox Latest (${{ steps.version.outputs.tag }})" \
            --notes "This release always points to the latest version. Current: **${{ steps.version.outputs.tag }}**

### Download
- **DMG**: [Vox-arm64.dmg](https://github.com/rodrigoluizs/vox/releases/download/latest/Vox-arm64.dmg)
- **Zip**: [Vox-arm64-mac.zip](https://github.com/rodrigoluizs/vox/releases/download/latest/Vox-arm64-mac.zip)" \
            out/Vox-arm64.dmg out/Vox-arm64-mac.zip

          echo "Latest release updated"
