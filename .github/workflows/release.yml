name: Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: "Semver bump type"
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      dry_run:
        description: "Dry run - build and sign but skip GitHub Release creation and version commit"
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  release:
    name: Build, Sign & Release
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: 22
          cache: npm

      - name: Bump version
        id: version
        run: |
          CURRENT=$(node -p "require('./package.json').version")
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

          case "${{ inputs.release_type }}" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          npm version "$NEW_VERSION" --no-git-tag-version

          echo "tag=v${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "Bumped $CURRENT -> $NEW_VERSION (${{ inputs.release_type }})"

      - name: Install dependencies
        run: npm ci

      - name: Import code signing certificate
        env:
          CERTIFICATE_P12_BASE64: ${{ secrets.CERTIFICATE_P12_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        run: |
          # Decode the certificate
          CERTIFICATE_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$CERTIFICATE_P12_BASE64" | base64 --decode > "$CERTIFICATE_PATH"

          # Create a temporary keychain
          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 24)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import the certificate into the keychain
          security import "$CERTIFICATE_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Allow codesign to access the keychain without UI prompt
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            "$KEYCHAIN_PATH"

          # Add the keychain to the search list (prepend so it's found first)
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

      - name: Prepare App Store Connect API key
        env:
          APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_BASE64 }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
        run: |
          # notarytool expects the key at ~/private_keys/AuthKey_<ID>.p8
          mkdir -p ~/private_keys
          echo "$APPLE_API_KEY_BASE64" | base64 --decode > ~/private_keys/AuthKey_${APPLE_API_KEY_ID}.p8

      - name: Build app
        run: npm run build

      - name: Package and sign (DMG + zip)
        env:
          # electron-builder uses these for signing
          CSC_KEYCHAIN: ${{ env.KEYCHAIN_PATH }}
          # electron-builder uses these for notarization (built-in CI notarization)
          APPLE_API_KEY: ~/private_keys/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER_ID }}
        run: npx electron-builder --mac dmg zip --publish never

      - name: Clean up keychain
        if: always()
        run: |
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH"
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: vox-${{ steps.version.outputs.version }}-mac
          path: |
            out/*.dmg
            out/*.zip
          if-no-files-found: error

      - name: Prepare release assets
        if: ${{ !inputs.dry_run }}
        run: |
          # Find the built files
          DMG=$(find out -name "*.dmg" -type f | head -1)
          ZIP=$(find out -name "*.zip" -type f | head -1)

          # Create copies with stable names (no version) for the latest release
          cp "$DMG" out/Vox-arm64.dmg
          cp "$ZIP" out/Vox-arm64-mac.zip

          echo "DMG=$DMG" >> "$GITHUB_ENV"
          echo "ZIP=$ZIP" >> "$GITHUB_ENV"

      - name: Commit version bump
        if: ${{ !inputs.dry_run }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add package.json package-lock.json
          git commit -m "chore(release): bump version to ${{ steps.version.outputs.version }}"
          git push origin HEAD:main

      - name: Create versioned GitHub Release
        if: ${{ !inputs.dry_run }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"

          git tag "$TAG"
          git push origin "$TAG"

          gh release create "$TAG" \
            --title "Vox $TAG" \
            --generate-notes \
            "$DMG" "$ZIP"

          echo "Versioned release created: $TAG"

      - name: Update latest release
        if: ${{ !inputs.dry_run }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Delete existing latest release and tag if they exist
          gh release delete latest --yes 2>/dev/null || true
          git push origin :refs/tags/latest 2>/dev/null || true

          # Create new latest tag pointing to current commit
          git tag -f latest
          git push origin latest

          # Create the latest release with stable-name assets
          gh release create latest \
            --title "Vox Latest (${{ steps.version.outputs.tag }})" \
            --notes "$(cat <<'NOTES'
          This release always points to the latest version. Current: **${{ steps.version.outputs.tag }}**

          ### Download
          - **DMG**: [Vox-arm64.dmg](https://github.com/app-vox/vox/releases/download/latest/Vox-arm64.dmg)
          - **Zip**: [Vox-arm64-mac.zip](https://github.com/app-vox/vox/releases/download/latest/Vox-arm64-mac.zip)
          NOTES
          )" \
            out/Vox-arm64.dmg out/Vox-arm64-mac.zip

          echo "Latest release updated"
